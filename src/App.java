import java.util.function.Function;

    /**
     * 함수형 인터페이스
     * Functional Interface
     * 단 하나의 추상메소드가 정의가능한 인터페이스
     * 인터페이스가 함수형 인터페이스임을 나타내는 수단으로서
     * @FunctionalInterface 라는 Annotation 이 존재
     * 그러나 명시적으로 Annotation 을 지정하지않더라도
     * 단 하나의 추상메소드가 정의된 인터페이스 인 경우
     * 자바 컴파일러에서 함수형 인터페이스로 취급될 수 있다.
     * 
     * 함수형 인터페이스에서는 Type (형) 추론이 가능하다
     * 
     * 추가 키워드 : 추상 클래스와 인터페이스의 차이는?
     * 
     * 함수형 인터페이스가 등장하게된 원인
     * 
     * 자바 1.7부터 <> 연산자를 이용한 Type 을 개발자가 알아볼 수 있도록
     * 전달할 수 있게 됨
     * 그러나 컴파일 과정중 타입 소거가 되면서 순차적으로 호출되는 부분에서
     * 해당 인자의 Type 을 런타임과정중 알 수가 없음.
     * 따라서 컴파일러에서 명시적으로 타입을 다시 확인할 수 있도록 처리해야함
     * 
     * 자바가 1.8 버전으로 업그레이드가 되면서 람다식을 공식적으로 지원하게됨
     * 이 때에 위와같이 타입소거가 발생될 경우 람다식에서 타입을 알 수 없어
     * 정상적으로 함수들을 실행할 수 없게됨.
     * 람다식에서 정상적으로 타입을 알 수 있도록 별도의 처리가 필요해짐
     * 따라서 등장한 것이 함수형 인터페이스
     * 함수형 인터페이스는 단 하나의 추상 메소드로 정의가 가능한 인터페이스
     * 이 때 해당하는 추상메소드의 시그니처가 (메소드의 이름과 파라미터 -> 오버로딩 생각하면 편함)
     * 이미 정의되어있기 때문에 이를 통해서 컴파일시 사라진 타입 등의 생략된 정보를
     * 추론할 수 있게됨
     * 
     * 단 함수형 인터페이스는 단 하나의 추상 메소드만을 정의할 수 있으나,
     * default 메소드와 static 메소드는 제외 (인터페이스 상속시 별도 구현이 필요한 부분이 아님)
     * 
     * 자바에서 기본적으로 제공하는 함수형 인터페이스는
     * Functions
     * Supplier
     * Consumer
     * Predicate
     * Operator
     * Legacy Functional Interface
     */
public class App {
    public static void main(String[] args) throws Exception {
    }
}
